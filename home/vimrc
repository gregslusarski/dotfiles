" = GENERAL"{{{1
" --------------
" viszu's vimrc - https://github.com/viszu
" Disable vi compatibilty restrictions
set nocompatible
filetype off " required! for Vundle
" - Vundle"{{{2

" :BundleList          - list configured bundles
" :BundleInstall(!)    - install(update) bundles
" :BundleSearch(!) foo - search(or refresh cache first) for foo
" :BundleClean(!)      - confirm(or auto-approve) removal of unused bundles

set rtp+=~/.vim/bundle/vundle/
call vundle#rc()

" let Vundle manage Vundle
" required!
Bundle 'gmarik/vundle'

" original repos on github:
Bundle 'tpope/vim-fugitive'
Bundle 'tpope/vim-unimpaired'
Bundle 'tpope/vim-commentary'
Bundle 'tpope/vim-surround'
Bundle 'tpope/vim-repeat'
Bundle 'tpope/vim-eunuch'
Bundle 'tpope/vim-dispatch'
Bundle 'tpope/vim-obsession'
Bundle 'tpope/vim-git'
Bundle 'tpope/vim-rails'
Bundle 'tpope/vim-rake'
Bundle 'vim-ruby/vim-ruby'
Bundle 'Raimondi/delimitMate'
Bundle 'godlygeek/tabular'
Bundle 'vim-scripts/Gundo'
Bundle 'kien/ctrlp.vim'
Bundle 'scrooloose/nerdtree'
Bundle 'mileszs/ack.vim'
Bundle 'airblade/vim-gitgutter'
Bundle 'Valloric/YouCompleteMe'
Bundle 'scrooloose/syntastic'
Bundle 'SirVer/ultisnips'
Bundle 'spolu/dwm.vim'
Bundle 'itchyny/lightline.vim'
Bundle 'majutsushi/tagbar.git'
Bundle 'Lokaltog/vim-easymotion.git'
Bundle 'goldfeld/vim-seek.git'
Bundle 'altercation/vim-colors-solarized'
Bundle 'rking/vim-detailed'
Bundle 'chrisbra/NrrwRgn'
Bundle 'jeetsukumaran/vim-buffergator'
Bundle 'skalnik/vim-vroom'
Bundle 'flazz/vim-colorschemes'
Bundle 'tristen/vim-sparkup'
" Bundle 'bling/vim-airline'
" Bundle 'rstacruz/sparkup'
" Bundle 'mattn/zencoding-vim'
" Bundle 'romainl/sparkup'
" Bundle 'bling/vim-bufferline'
" Bundle 'Lokaltog/vim-powerline'
" Bundle 'vim-scripts/Skittles-Dark'
" Bundle 'shawncplus/skittles_berry'
" Bundle 'hynek/vim-python-pep8-indent'
" Bundle 'viszu/vim-python-fold'
"}}}2
" Filetype detection:ON, plugin:ON, indent:ON
filetype plugin indent on " required! for Vundle
" - Path"{{{2
" for testing out custom vim scripts
set rtp+=~/vim_test,~/vim_test/after
" my snippets, spell file etc.
set rtp+=~/dotfiles/vim
"}}}2
" Enable syntax highlighting
syntax on
" - Support unicode characters"{{{2
if has("multi_byte")
  if &termencoding == ""
    let &termencoding = &encoding
  endif
  set encoding=utf-8
  setglobal fileencoding=utf-8
  set fileencodings=ucs-bom,utf-8,latin1
endif
"}}}2
" Use interactive shell
" set shellcmdflag=-ic
" Emulate typical editor navigation
set nostartofline
" Don't insert extra space(after .?!)
set nojoinspaces
" <C-a>, <C-x> fixup
set nrformats-=octal
" When creating a new line, set indentation same as previous line
set autoindent
" - Indentation"{{{2
set shiftwidth=2
set softtabstop=2
set tabstop=2
set expandtab
" set smarttab
" set shiftround
"}}}2
" - Folding"{{{2
set foldlevel=99
set foldmethod=marker
" Use custom fold text
set foldtext=CustomFoldText()
" }}}2
" Buffer becomes hidden when it is abandoned
set hidden
" Create new split window below the current one
set splitbelow
" Create vertical split window right of the current one
set splitright
set scrolloff=1
set sidescrolloff=5
set display+=lastline
" For regular expressions turn magic on
set magic
" Enable menu for command-line completion
set wildmenu
set wildmode=longest:full,full
set wildignore+=*.fo,*.xml,.svn,.git,.hg,*.pyc,*.o,*.a,*.class,*.obj,*.swp
set completeopt=menuone,preview
" - Display special characters for certain whitespace situations"{{{2
set list
if &listchars ==# 'eol:$'
  set listchars=tab:>\ ,trail:-,extends:>,precedes:<,nbsp:+
  if !has('win32') && (&termencoding ==# 'utf-8' || &encoding ==# 'utf-8')
    let &listchars = "tab:\u21e5\u00b7,trail:\u2022,extends:\u21c9,precedes:\u21c7,nbsp:\u00b7"
  endif
endif
" }}}2
" Search stuff
set incsearch
" Highlight search results
set hlsearch
" When sourcing this file, do not immediately turn on highlighting
nohlsearch
set ignorecase
set smartcase
set modeline
set modelines=5
" Lang for spell checker
set spelllang=en,pl
" Number of suggested words for spell checker popup
set spellsuggest=9
" Terminal title
set title
" Always show cursor position in statusline
set ruler
" set number
" This shows what you are typing as a command
set showcmd
set cmdheight=2
" Show matching brackets
set showmatch
" Always show status line
set laststatus=2
" set statusline=%t[%{strlen(&fenc)?&fenc:'none'},%{&ff}]%h%m%r%y%=%c,%l/%L\ %P
" set statusline=[%n]\ %<%.99f\ %h%w%m%r%{SL('CapsLockStatusline')}%y%{SL('fugitive#statusline')}%#ErrorMsg#%{SL('SyntasticStatuslineFlag')}%*%=%-14.(%l,%c%V%)\ %P
" Enable wordwrap
set textwidth=79 wrap linebreak
" Backspace
set backspace=indent,eol,start
set complete-=i
" Timeout for keycodes (such as arrow keys and function keys) is only 10ms
" Timeout for Vim keymaps is a second
set timeout timeoutlen=1000 ttimeoutlen=10
" Mouse support
set mouse=a
" Limit Vim's "hit-enter" messages
set shortmess=atI
" set fileformats+=mac
set viminfo^=!
" Look for file changes
set autoread
set autowrite
" - Backup, undo, history"{{{2
" Disable swapfile and backup
set nobackup
set noswapfile
" Enable persistent undo
set undofile
set undodir=~/tmp/vim/undo
if !isdirectory(expand(&undodir))
  call mkdir(expand(&undodir), "p")
endif
" Command-line history
if &history < 1000
  set history=1000
endif
" Netrw stuff
if !exists('g:netrw_list_hide')
  let g:netrw_list_hide = '^\.,\~$,^tags$'
endif

" = MAPPINGS"{{{1
" --------------
" Unbind the cursor keys in insert, normal and visual modes.
for prefix in ['i', 'n', 'v']
  for key in ['<Up>', '<Down>', '<Left>', '<Right>']
    exe prefix . "noremap " . key . " <Nop>"
  endfor
endfor
nn <Space> za
nn Q <Nop>
let mapleader = ','
let maplocalleader = '\\'
" Window navigation
" nn <C-h> <C-w>h
" nn <C-j> <C-w>j
" nn <C-k> <C-w>k
" nn <C-l> <C-w>l
" nn <C-c> <C-w>c
" Be consistent with bash
" Go to the 1st non blank
ino <C-a> <C-o>^
cno <C-a> <Home>
" Go to the end of a line
ino <C-e> <C-o>$
cno <C-e> <End>
" Write current buffer
nn <silent> <leader>s :w!<CR>
" Write all buffers and quit Vim
nn <leader>qq :wa!<CR>:q<CR>
" Write read-only files
cno W! w !sudo tee %
cno ara ar **/*.*
" Reselect visual block after indent/outdent
vn < <gv
vn > >gv
" Select (charwise) the contents of the current line, excluding indentation
" Great for pasting Python lines into REPLs.
nn vv ^vg_
" Easier linewise reselection
nn <leader>V V`]
" Make Y behave like other capitals
nn Y y$
nn <F12> "+
" Improve up/down movement on wrapped lines
nn j gj
nn k gk
" Toggle spell checking
nn <F3> :setl spell! spell?<CR>
" Toggle paste / nopaste
nn <silent> <F4> :setl paste!<CR>
" ino jk <Esc>
" ino JK <Esc>
" Center screen on next / prev found
nn N Nzz
nn n nzz
" Switch fast between buffers
" nn <leader>l :ls<CR>:b<Space>
" Open vimrc
nn <leader>ev :e $MYVIMRC<CR>
" Source vimrc
nn <leader>vs :source $MYVIMRC<CR>
" cd to the directory containing the file in the buffer
nn <silent> <leader>cd :lcd %:p:h<CR>:pwd<CR>
" print working directory
nn <silent> <leader>pw :pwd<CR>
" print directory of the current file
nn <silent> <leader>pf :echo expand('%:p:h')<CR>
" undo to last write
nn <silent> <leader>u :ea 1f<CR>
" nn <leader>e :e **/
" Select all text in current buffer
nn <silent> <leader>/ :noh<CR>
" Underline text, to create headers
nn <leader>- yypVr-
nn <leader>= yypVr=
nn <leader>` yypVr~
" Make <C-u> and <C-w> undoable
ino <C-u> <C-g>u<C-u>
ino <C-w> <C-g>u<C-w>
nn & :&&<CR>
xn & :&&<CR>
" Load matchit.vim, but only if the user hasn't installed a newer version.
if !exists('g:loaded_matchit') && findfile('plugin/matchit.vim', &rtp) ==# ''
  runtime! macros/matchit.vim
endif

" = ABBREVIATIONS"{{{1
cnorea H h
cnorea hg helpg
cnorea ag Ack
cnorea agt Ack -i --text
cnorea agr Ack -i --ruby
cnorea agp Ack -i --python
cnorea agv Ack -i --vim
cnorea hag AckHelp

cnorea <silent> md !mkdir -p
cnorea <silent> mf !touch
cnorea <silent> .. cd ..
cnorea <silent> - cd -

" = PLUGINS SETTINGS & MAPPINGS"{{{1
" ----------------------------------
no <silent> <leader>e :NR<CR>
" - Lighline"{{{2
let g:lightline = {
      \ 'colorscheme': 'powerline',
      \ 'active': {
      \   'left': [ [ 'mode', 'paste' ], [ 'fugitive', 'filename' ], ['ctrlpmark'] ],
      \   'right': [[ 'lineinfo', 'syntastic' ], ['percent'], [ 'fileformat', 'fileencoding', 'filetype']]
      \ },
      \ 'component': {
      \   'lineinfo': '⭡ %3l:%-2v',
      \ },
      \ 'component_function': {
      \   'fugitive': 'MyFugitive',
      \   'filename': 'MyFilename',
      \   'fileformat': 'MyFileformat',
      \   'filetype': 'MyFiletype',
      \   'fileencoding': 'MyFileencoding',
      \   'mode': 'MyMode',
      \   'syntastic': 'SyntasticStatuslineFlag',
      \   'ctrlpmark': 'CtrlPMark',
      \ },
      \ 'subseparator': { 'left': '|', 'right': '|' }
      \ }

function! MyModified()
  return &ft =~ 'help' ? '' : &modified ? '+' : &modifiable ? '' : '-'
endfunction

function! MyReadonly()
  return &ft !~? 'help' && &readonly ? '' : ''
endfunction

function! MyFilename()
  let fname = expand('%:t')
  return fname == 'ControlP' ? g:lightline.ctrlp_item :
        \ fname == '__Tagbar__' ? g:lightline.fname :
        \ fname =~ '__Gundo\|NERD_tree' ? '' :
        \ &ft == 'vimfiler' ? vimfiler#get_status_string() :
        \ &ft == 'unite' ? unite#get_status_string() :
        \ &ft == 'vimshell' ? vimshell#get_status_string() :
        \ ('' != MyReadonly() ? MyReadonly() . ' ' : '') .
        \ ('' != fname ? fname : '[No Name]') .
        \ ('' != MyModified() ? ' ' . MyModified() : '')
endfunction

function! MyFugitive()
  try
    if expand('%:t') !~? 'Tagbar\|Gundo\|NERD' && &ft !~? 'vimfiler' && exists('*fugitive#head')
      let mark = ' '  " edit here for cool mark
      let _ = fugitive#head()
      return strlen(_) ? mark._ : ''
    endif
  catch
  endtry
  return ''
endfunction

function! MyFileformat()
  return winwidth('.') > 70 ? &fileformat : ''
endfunction

function! MyFiletype()
  return winwidth('.') > 70 ? (strlen(&filetype) ? &filetype : 'no ft') : ''
endfunction

function! MyFileencoding()
  return winwidth('.') > 70 ? (strlen(&fenc) ? &fenc : &enc) : ''
endfunction

function! MyMode()
  let fname = expand('%:t')
  return fname == '__Tagbar__' ? 'Tagbar' :
        \ fname == 'ControlP' ? 'CtrlP' :
        \ fname == '__Gundo__' ? 'Gundo' :
        \ fname == '__Gundo_Preview__' ? 'Gundo Preview' :
        \ fname =~ 'NERD_tree' ? 'NERDTree' :
        \ &ft == 'unite' ? 'Unite' :
        \ &ft == 'vimfiler' ? 'VimFiler' :
        \ &ft == 'vimshell' ? 'VimShell' :
        \ winwidth('.') > 60 ? lightline#mode() : ''
endfunction

function! CtrlPMark()
  if expand('%:t') =~ 'ControlP'
    call lightline#link('iR'[g:lightline.ctrlp_regex])
    return lightline#concatenate([g:lightline.ctrlp_prev, g:lightline.ctrlp_item
          \ , g:lightline.ctrlp_next], 0)
  else
    return ''
  endif
endfunction

let g:ctrlp_status_func = {
  \ 'main': 'CtrlPStatusFunc_1',
  \ 'prog': 'CtrlPStatusFunc_2',
  \ }

function! CtrlPStatusFunc_1(focus, byfname, regex, prev, item, next, marked)
  let g:lightline.ctrlp_regex = a:regex
  let g:lightline.ctrlp_prev = a:prev
  let g:lightline.ctrlp_item = a:item
  let g:lightline.ctrlp_next = a:next
  return lightline#statusline(0)
endfunction

function! CtrlPStatusFunc_2(str)
  return lightline#statusline(0)
endfunction

let g:tagbar_status_func = 'TagbarStatusFunc'

function! TagbarStatusFunc(current, sort, fname, ...) abort
    let g:lightline.fname = a:fname
  return lightline#statusline(0)
endfunction

let g:unite_force_overwrite_statusline = 0
let g:vimfiler_force_overwrite_statusline = 0
let g:vimshell_force_overwrite_statusline = 0

" - Sparkup"{{{2
let g:sparkupExecuteMapping='<leader>j'
let g:sparkupNextMapping='<leader>n'
" let g:sparkupPreviousMapping='<c-f>'

" - Buffergator"{{{2
" let g:buffergator_split_size = 30
" let g:buffergator_display_regime = "bufname"
let g:buffergator_autoexpand_on_split = 0
let g:buffergator_suppress_keymaps = 1
nn <silent> <leader>b :BuffergatorToggle<CR>

" - Ultisnips"{{{2
let g:UltiSnipsExpandTrigger="<c-j>"
let g:UltiSnipsJumpForwardTrigger="<c-j>"
let g:UltiSnipsJumpBackwardTrigger="<c-k>"
let g:UltiSnipsListSnippets="<c-s-l>"
" let g:UltiSnipsSnippetsDir="~/dotfiles/vim/UltiSnips"
" let g:UltiSnipsSnippetDirectories=["Ultisnips"]
let g:snips_author="viszu"
" Since this ultisnips fork can also use snipmate snips, prefer ultisnips snips
" let g:always_use_first_snippet = 1

" - Fugitive"{{{2
nn <silent> <leader>gs :Gstatus<CR>
nn <silent> <leader>gd :Gdiff<CR>
nn <silent> <leader>gc :Gcommit<CR>
nn <silent> <leader>gb :Gblame<CR>
nn <silent> <leader>gl :Glog<CR>
nn <silent> <leader>gp :Git push<CR>

" - Tabularize"{{{2
nn <leader>a& :Tabularize /&<CR>
vn <leader>a& :Tabularize /&<CR>
nn <leader>a= :Tabularize /=<CR>
vn <leader>a= :Tabularize /=<CR>
nn <leader>a: :Tabularize /:<CR>
vn <leader>a: :Tabularize /:<CR>
nn <leader>a:: :Tabularize /:\zs<CR>
vn <leader>a:: :Tabularize /:\zs<CR>
nn <leader>a, :Tabularize /,<CR>
vn <leader>a, :Tabularize /,<CR>
nn <leader>a<Bar> :Tabularize /<Bar><CR>
vn <leader>a<Bar> :Tabularize /<Bar><CR>

" - NERDTree"{{{2
nn <silent> <C-e> :NERDTreeToggle<CR>
let g:NERDTreeShowBookmarks=1
let g:NERDTreeHijackNetrw=0
let g:NERDTreeMinimalUI=1
let g:NERDTreeChDirMode=0
let g:NERDTreeQuitOnOpen=1
" let g:NERDTreeShowHidden=1

" - CtrlP"{{{2
let g:ctrlp_custom_ignore = {
    \ 'dir':  '\.git$\|\.hg$\|\.svn$\|tmp$\|Downloads$',
    \ 'file': '\.exe$\|\.so$\|\.dll$' }
let g:ctrlp_switch_buffer = 0
let g:ctrlp_working_path_mode = 0
" let g:ctrlp_user_command = 'find %s -type f'
" let g:ctrlp_follow_symlinks = 1
" let g:ctrlp_show_hidden = 1

" - Syntastic"{{{2
nn <silent> <leader>x :SyntasticCheck<CR>
" Disable all ruby warnings. Default setting is '-w -T1 -c'
let g:syntastic_ruby_mri_args='-T1 -c'

let g:syntastic_python_checkers=['flake8']
let g:syntastic_python_flake8_args='--ignore=E111,E501,E226'

let g:syntastic_auto_jump=1
let g:syntastic_auto_loc_list=1
let g:syntastic_loc_list_height=5
let g:syntastic_enable_signs=0
let g:syntastic_echo_current_error=0

" - Powerline"{{{2
" let g:Powerline_symbols = 'fancy'
" let g:Powerline_stl_path_style = 'filename'
" call Pl#Theme#InsertSegment('charcode', 'after', 'filetype')

" - Commentary"{{{2
" autocmd FileType python set commentstring=#\ %s
xmap \ <Plug>Commentary
nmap \ <Plug>Commentary
nmap \\ <Plug>CommentaryLine
nmap \u <Plug>CommentaryUndo

" - Gundo"{{{2
nn <silent> <F2> :GundoToggle<CR>

" - Dwm"{{{2
let g:dwm_master_pane_width="50%"

" - delimitMate"{{{2
" let delimitMate_matchpairs = "(:),[:],{:},<:>"

" - Tagbar"{{{2
let g:tagbar_autofocus = 1
nn <silent> <F7> :TagbarToggle<CR>
nn <silent> <F8> :TagbarOpenAutoClose<CR>

" - EasyMotion"{{{2
let g:EasyMotion_leader_key = '\'
let g:EasyMotion_do_shade = 0

" - Dispatch"{{{2
" nn <F9> :Dispatch<CR>

" " - Airline"{{{2
" let g:airline_theme='simple'
" let g:airline_powerline_fonts=1
" " let g:airline_enable_fugitive=1
" " '%t' - only filename
" let g:airline_section_c = '%t'
" " filetype
" let g:airline_section_x = ''
" " let g:airline_enable_syntastic=1
" " let g:bufferline_echo = 0
" set noshowmode

" " - Snipmate"{{{2
" let g:snippets_dir='~/.vim/bundle/snippets/snippets'

" " - Flake8"{{{2
" " E111 = indentation is not a multiple of four
" let g:flake8_ignore="E111"

" " - Neocomplcache"{{{2
" let g:neocomplcache_enable_at_startup = 1
" " Use smartcase.
" let g:neocomplcache_enable_smart_case = 1
" " let g:neocomplcache_force_overwrite_completefunc=1
" " <CR>: close popup and save indent.
" ino <expr><CR>  neocomplcache#smart_close_popup() . "\<CR>"
" " <TAB>: completion.
" ino <expr><TAB>  pumvisible() ? "\<C-n>" : "\<TAB>"
" ino <expr><S-TAB>  pumvisible() ? "\<C-p>" : "\<S-TAB>"
" " <C-h>, <BS>: close popup and delete backword char.
" ino <expr><C-h> neocomplcache#smart_close_popup()."\<C-h>"
" ino <expr><BS> neocomplcache#smart_close_popup()."\<C-h>"

" " - Neosnippet"{{{2
" " Plugin key-mappings.
" imap <C-k>     <Plug>(neosnippet_expand_or_jump)
" smap <C-k>     <Plug>(neosnippet_expand_or_jump)
" " SuperTab like snippets behavior.
" " imap <expr><TAB> neosnippet#expandable_or_jumpable() ? "\<Plug>(neosnippet_expand_or_jump)" : pumvisible() ? "\<C-n>" : "\<TAB>"
" " smap <expr><TAB> neosnippet#expandable_or_jumpable() ? "\<Plug>(neosnippet_expand_or_jump)" : "\<TAB>"
" " For snippet_complete marker.
" if has('conceal')
"   set conceallevel=2 concealcursor=i
" endif
" " Tell Neosnippet about the other snippets
" let g:neosnippet#snippets_directory='~/.vim/bundle/snippets/snippets'
" " Disable built-in snippets
" let g:neosnippet#disable_runtime_snippets = {
" \   '_' : 1,
" \ }
" let g:neosnippet#enable_snipmate_compatibility = 1


" Supertab
" au FileType *
"   \ if &omnifunc != '' |
"   \   call SuperTabChain(&omnifunc, "<c-p>") |
"   \   call SuperTabSetDefaultCompletionType("<c-x><c-u>") |
"   \ endif

" Pyflakes
" Error highlight color
"highlight SpellBad term=reverse ctermfg=0 ctermbg=3

" Taglist
"map <leader>t :TlistToggle<CR>
"let Tlist_Inc_Winwidth=0
"let Tlist_Compact_Format=1

" Rope-vim
"map <leader>j :RopeGotoDefinition<CR>
"map <leader>r :RopeRename<CR>
"}}}2
" = AUTOCOMMANDS"{{{1
" -------------------
augroup General
  au!
  " Remove any trailing whitespace that is in the file
  au BufRead,BufWrite * if ! &bin | silent! %s/\s\+$//ge | endif

  " Jumps to the last known position in a file just after opening it
  au BufReadPost *
    \ if line("'\"") > 1 && line("'\"") <= line("$") |
      \ exe "normal! g`\"" |
    \ endif

  " When leaving insert mode, set nopaste
  au InsertLeave * set nopaste

  " Turns off error bells
  set noerrorbells visualbell t_vb=
  au GUIEnter * set vb t_vb=

  " Resize splits when the window is resized
  au VimResized * :wincmd =

augroup END

" augroup Plugins
"   au!
"   autocmd BufWritePost *.py call Flake8()
" augroup END

augroup FTCheck
  " filetype.vim
  au!
  au BufNewFile,BufRead *.rss,*.atom set ft=xml
  au BufNewFile,BufRead *.txt,README,HELP,INSTALL,NEWS,TODO if &ft == ""
    \ | set ft=text|endif
  " UltiSnips is missing a setf trigger for snippets on BufEnter
  au BufEnter *.snippets setf snippets
augroup END

augroup FTOptions
  " ftplugin
  au!
  " au FileType markdown setl sw=4 sts=4
  " set nolist for quickfix window
  au FileType qf setl nolist
  au FileType python setl fo=croql
  au FileType python nn <buffer> <F5> :!python %<CR>
  au FileType c,cpp,cs,java setl fdm=syntax cin
  au FileType git,gitcommit setl fdm=syntax
  au FileType gitcommit setl spell
  au FileType snippets set noet
  " Ruby
  au FileType ruby,eruby let ruby_fold = 1
  " au FileType ruby,eruby let ruby_minlines = 500
  au FileType ruby,eruby let g:rubycomplete_buffer_loading = 1
  au FileType ruby,eruby let g:rubycomplete_rails = 1
  au FileType ruby,eruby let g:rubycomplete_classes_in_global = 1
  au FileType ruby,eruby setl tw=79 comments=:#\  isfname+=:
  au FileType ruby,eruby nn <buffer> <F5> :!clear<CR>:!ruby %<CR>
  au FileType ruby,eruby nn <buffer> <F9> :!clear<CR>:!rspec %<CR>
  " Dispatch.vim
  au FileType ruby,eruby let b:dispatch = 'rspec %'

  au FileType ruby inorea ARB ActiveRecord::Base
  au FileType ruby inorea AC ApplicationController
  au FileType eruby :UltiSnipsAddFiletypes eruby.html

  "html
  au FileType html nn <buffer> <F5> :!clear<CR>:!chromium-browser %<CR><CR>
augroup END

" = FUNCTIONS{{{1
" ---------------
" - Stab"{{{2
" Set tabstop, softtabstop and shiftwidth to the same value + set et / noet
" Inspired by http://vimcasts.org/episodes/tabs-and-spaces/
" retab! 4 spaces into 2
nn <leader>t2 :call Stab()<CR>4 noet<CR>:retab!<CR>:call Stab()<CR>2 et<CR>:retab!<CR>
" retab! 2 spaces into 4
nn <leader>t4 :call Stab()<CR>2 noet<CR>:retab!<CR>:call Stab()<CR>4 et<CR>:retab!<CR>
nn <leader>tt :call Stab()<CR>
command! -nargs=* Stab call Stab()
fun! Stab()
  let message = '{sw=sts=ts=} {et / noet}: '
  let arglist = split(input(message))
  let len_arglist = len(arglist)
  if len_arglist > 0
    let tabstop = 1 * arglist[0]
    if tabstop > 0
      let &l:sw = tabstop
      let &l:sts = tabstop
      let &l:ts = tabstop
    endif
    if len_arglist > 1
      let expandtab = arglist[1]
      if expandtab =~ '\(no\)\?et'
        execute 'setl '.expandtab
      endif
    endif
  endif
  call SummarizeTabs()
endfun

nn <leader>ti :call SummarizeTabs()<CR>
fun! SummarizeTabs()
  try
    echo "\r"
    echohl ModeMsg
    echon 'sw='.&sw ' sts='.&sts ' ts='.&ts
    if &et
      echon ' et'
    else
      echon ' noet'
    endif
  finally
    echohl None
  endtry
endfun

" - CloseHiddenBuffers"{{{2
" Wipe all buffers which are not active (i.e. not visible in a window/tab)
" Using elements from each of these:
"   http://stackoverflow.com/questions/2974192
"   http://stackoverflow.com/questions/1534835
nn <leader>ch :call CloseHiddenBuffers()<CR>
command! -nargs=* Only call CloseHiddenBuffers()
fun! CloseHiddenBuffers()
  " figure out which buffers are visible in any tab
  let visible = {}
  for t in range(1, tabpagenr('$'))
    for b in tabpagebuflist(t)
      let visible[b] = 1
    endfor
  endfor
  " close any buffer that are loaded and not visible
  let l:tally = 0
  for b in range(1, bufnr('$'))
    if bufloaded(b) && !has_key(visible, b)
      let l:tally += 1
      exe 'bw ' . b
    endif
  endfor
  echon "Deleted " . l:tally . " buffers"
endfun

" - CustomFoldText{{{2
fun! CustomFoldText()
  "get first non-blank line
  let fs = v:foldstart
  while getline(fs) =~ '^\s*$' | let fs = nextnonblank(fs + 1)
  endwhile
  if fs > v:foldend
      let line = getline(v:foldstart)
  else
      let line = substitute(getline(fs), '\t', repeat(' ', &tabstop), 'g')
  endif

  let w = winwidth(0) - &foldcolumn - (&number ? 8 : 0)
  let foldSize = 1 + v:foldend - v:foldstart
  let foldSizeStr = " " . foldSize . " lines "
  let foldLevelStr = repeat("+--", v:foldlevel)
  let lineCount = line("$")
  let foldPercentage = printf("[%.1f", (foldSize*1.0)/lineCount*100) . "%] "
  let expansionString = repeat(".", w - strwidth(foldSizeStr.line.foldLevelStr.foldPercentage))
  return line . expansionString . foldSizeStr . foldPercentage . foldLevelStr
endfun

" = GUI & COLOR SCHEME"{{{1
" -------------------------
if has('gui_running')
  if has('unix')
    " set guifont=Menlo\ for\ Powerline\ 11
    " set guifont=Menlo\ for\ Powerline\ 10
    set guifont=Droid\ Sans\ Mono\ for\ Powerline\ 11
  elseif has('gui_win32') || has('gui_win64')
    let g:skip_loading_mswin=1
    set guifont=Droid_Sans_Mono:h10.2
    cd c:\
  endif
  colorscheme detailed
  set lines=36 columns=80
  " Turn off menu, toolbar, scrollbars
  set guioptions=aegit
else
  " Terminal
  " set t_Co=256 t_md=
endif

set background=dark
" let g:solarized_menu=0
" let g:solarized_termtrans=1
" let g:solarized_termcolors=256
" let g:solarized_contrast="high"
" let g:solarized_visibility="high"
" colorscheme solarized
" colorscheme detailed
" colorscheme koehler
" colorscheme skittles_dark
" colorscheme 256-jungle
colorscheme charged-256
" Get rid of the underline and bold in fold text
hi Folded term=none gui=none
" SignColumn will use same bg color as linenumber (GitGutter will set it)
hi clear SignColumn
" hi SignColumn ctermbg=0 guibg=DarkGrey

" = FIXUPS"{{{1
" -------------
" Fix arrow key navigation in insert mode
" imap <ESC>oA <ESC>ki
" imap <ESC>oB <ESC>ji
" imap <ESC>oC <ESC>li
" imap <ESC>oD <ESC>hi
